// Code generated by go-swagger; DO NOT EDIT.

package erc_20_swap_pairs

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/runtime"

	"github.com/qydata/ct-evm-compatible-bridge-api/models"
)

// GetErc20SwapPairsOKCode is the HTTP code returned for type GetErc20SwapPairsOK
const GetErc20SwapPairsOKCode int = 200

/*GetErc20SwapPairsOK Success

swagger:response getErc20SwapPairsOK
*/
type GetErc20SwapPairsOK struct {

	/*
	  In: Body
	*/
	Payload *models.Erc20SwapPairs `json:"body,omitempty"`
}

// NewGetErc20SwapPairsOK creates GetErc20SwapPairsOK with default headers values
func NewGetErc20SwapPairsOK() *GetErc20SwapPairsOK {

	return &GetErc20SwapPairsOK{}
}

// WithPayload adds the payload to the get erc20 swap pairs o k response
func (o *GetErc20SwapPairsOK) WithPayload(payload *models.Erc20SwapPairs) *GetErc20SwapPairsOK {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the get erc20 swap pairs o k response
func (o *GetErc20SwapPairsOK) SetPayload(payload *models.Erc20SwapPairs) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *GetErc20SwapPairsOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(200)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// GetErc20SwapPairsBadRequestCode is the HTTP code returned for type GetErc20SwapPairsBadRequest
const GetErc20SwapPairsBadRequestCode int = 400

/*GetErc20SwapPairsBadRequest Bad Request

swagger:response getErc20SwapPairsBadRequest
*/
type GetErc20SwapPairsBadRequest struct {

	/*
	  In: Body
	*/
	Payload *models.Error `json:"body,omitempty"`
}

// NewGetErc20SwapPairsBadRequest creates GetErc20SwapPairsBadRequest with default headers values
func NewGetErc20SwapPairsBadRequest() *GetErc20SwapPairsBadRequest {

	return &GetErc20SwapPairsBadRequest{}
}

// WithPayload adds the payload to the get erc20 swap pairs bad request response
func (o *GetErc20SwapPairsBadRequest) WithPayload(payload *models.Error) *GetErc20SwapPairsBadRequest {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the get erc20 swap pairs bad request response
func (o *GetErc20SwapPairsBadRequest) SetPayload(payload *models.Error) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *GetErc20SwapPairsBadRequest) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(400)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// GetErc20SwapPairsInternalServerErrorCode is the HTTP code returned for type GetErc20SwapPairsInternalServerError
const GetErc20SwapPairsInternalServerErrorCode int = 500

/*GetErc20SwapPairsInternalServerError internal server error

swagger:response getErc20SwapPairsInternalServerError
*/
type GetErc20SwapPairsInternalServerError struct {

	/*
	  In: Body
	*/
	Payload *models.Error `json:"body,omitempty"`
}

// NewGetErc20SwapPairsInternalServerError creates GetErc20SwapPairsInternalServerError with default headers values
func NewGetErc20SwapPairsInternalServerError() *GetErc20SwapPairsInternalServerError {

	return &GetErc20SwapPairsInternalServerError{}
}

// WithPayload adds the payload to the get erc20 swap pairs internal server error response
func (o *GetErc20SwapPairsInternalServerError) WithPayload(payload *models.Error) *GetErc20SwapPairsInternalServerError {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the get erc20 swap pairs internal server error response
func (o *GetErc20SwapPairsInternalServerError) SetPayload(payload *models.Error) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *GetErc20SwapPairsInternalServerError) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(500)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}
